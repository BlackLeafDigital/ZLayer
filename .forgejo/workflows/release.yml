name: Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version tag (e.g., v1.0.0)'
        required: true
        type: string
      sha:
        description: 'Commit SHA for the release'
        required: false
        type: string
      artifact_base_url:
        description: 'Base URL for temp artifact packages from build workflow'
        required: true
        type: string

env:
  CARGO_TERM_COLOR: always

jobs:
  # ===========================================
  # Detect release type
  # ===========================================
  detect:
    runs-on: ubuntu-latest
    outputs:
      binary: ${{ steps.check.outputs.binary }}
      crate_name: ${{ steps.check.outputs.crate_name }}
      sdk_name: ${{ steps.check.outputs.sdk_name }}
      docker: ${{ steps.check.outputs.docker }}
      is_major: ${{ steps.check.outputs.is_major }}
      is_general: ${{ steps.check.outputs.is_general }}
      version: ${{ steps.check.outputs.version }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ inputs.sha || github.ref }}
          fetch-depth: 0
      - name: Detect release type
        id: check
        run: |
          if [[ -n "${{ inputs.version }}" ]]; then
            TAG="${{ inputs.version }}"
          else
            TAG="${{ github.ref_name }}"
          fi
          VERSION=$(echo "$TAG" | grep -oP '\d+\.\d+\.\d+' || echo "0.0.0")
          echo "version=$VERSION" >> $GITHUB_OUTPUT

          if [[ "$TAG" == major-v* ]]; then
            echo "is_major=true" >> $GITHUB_OUTPUT
            echo "is_general=true" >> $GITHUB_OUTPUT
            echo "binary=true" >> $GITHUB_OUTPUT
            echo "docker=true" >> $GITHUB_OUTPUT
          elif [[ "$TAG" == v[0-9]* ]]; then
            echo "is_general=true" >> $GITHUB_OUTPUT
            echo "binary=true" >> $GITHUB_OUTPUT
            echo "docker=true" >> $GITHUB_OUTPUT
          elif [[ "$TAG" == docker-v* ]]; then
            echo "docker=true" >> $GITHUB_OUTPUT
          elif [[ "$TAG" == spec-v* ]]; then
            echo "crate_name=zlayer-spec" >> $GITHUB_OUTPUT
          elif [[ "$TAG" == core-v* ]]; then
            echo "crate_name=zlayer-core" >> $GITHUB_OUTPUT
          elif [[ "$TAG" == registry-v* ]]; then
            echo "crate_name=zlayer-registry" >> $GITHUB_OUTPUT
          elif [[ "$TAG" == obs-v* ]]; then
            echo "crate_name=zlayer-observability" >> $GITHUB_OUTPUT
          elif [[ "$TAG" == builder-v* ]]; then
            echo "crate_name=zlayer-builder" >> $GITHUB_OUTPUT
          elif [[ "$TAG" == overlay-v* ]]; then
            echo "crate_name=zlayer-overlay" >> $GITHUB_OUTPUT
          elif [[ "$TAG" == init-v* ]]; then
            echo "crate_name=zlayer-init-actions" >> $GITHUB_OUTPUT
          elif [[ "$TAG" == scheduler-v* ]]; then
            echo "crate_name=zlayer-scheduler" >> $GITHUB_OUTPUT
          elif [[ "$TAG" == storage-v* ]]; then
            echo "crate_name=zlayer-storage" >> $GITHUB_OUTPUT
          elif [[ "$TAG" == tunnel-v* ]]; then
            echo "crate_name=zlayer-tunnel" >> $GITHUB_OUTPUT
          elif [[ "$TAG" == build-v* ]]; then
            echo "crate_name=zlayer-builder" >> $GITHUB_OUTPUT
            echo "binary=true" >> $GITHUB_OUTPUT
          elif [[ "$TAG" == rust-sdk-v* ]]; then
            echo "sdk_name=rust" >> $GITHUB_OUTPUT
          elif [[ "$TAG" == py-sdk-v* ]]; then
            echo "sdk_name=python" >> $GITHUB_OUTPUT
          elif [[ "$TAG" == ts-sdk-v*  ]]; then
            echo "sdk_name=typescript" >> $GITHUB_OUTPUT
          elif [[ "$TAG" == go-sdk-v* ]]; then
            echo "sdk_name=go" >> $GITHUB_OUTPUT
          elif [[ "$TAG" == c-sdk-v* ]]; then
            echo "sdk_name=c" >> $GITHUB_OUTPUT
          fi

  # ===========================================
  # Upload binaries to registry (download from temp packages)
  # ===========================================
  upload-binaries:
    needs: [detect]
    if: needs.detect.outputs.binary == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Download artifacts from temp storage
        run: |
          BASE_URL="${{ inputs.artifact_base_url }}"
          mkdir -p artifacts

          for name in zlayer-linux-amd64 zlayer-linux-arm64 zlayer-darwin-amd64 zlayer-darwin-arm64 zlayer-build-linux-amd64 zlayer-build-linux-arm64 zlayer-build-darwin-amd64 zlayer-build-darwin-arm64 zlayer-cli-linux-amd64 zlayer-cli-linux-arm64 zlayer-cli-darwin-amd64 zlayer-cli-darwin-arm64; do
            echo "Downloading ${name}.tar.gz from temp storage..."
            curl -L --fail \
              --user "zachhandley:${{ secrets.FORGEJO_ACTIONS_TOKEN }}" \
              -o "artifacts/${name}.tar.gz" \
              "${BASE_URL}/${name}.tar.gz"
          done

      - name: Upload to Forgejo Packages
        run: |
          VERSION="${{ needs.detect.outputs.version }}"
          for artifact in artifacts/*.tar.gz; do
            filename=$(basename "$artifact")
            echo "Uploading $filename to final location..."
            curl --fail --user "zachhandley:${{ secrets.FORGEJO_ACTIONS_TOKEN }}" \
              --upload-file "$artifact" \
              "https://forge.blackleafdigital.com/api/packages/BlackLeafDigital/generic/zlayer/${VERSION}/${filename}"
          done

  # ===========================================
  # Merge to main (after binaries uploaded)
  # ===========================================
  merge-to-main:
    needs: [detect, upload-binaries]
    if: needs.detect.outputs.binary == 'true' || needs.detect.outputs.is_major == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ inputs.sha || github.ref }}
          fetch-depth: 0
          token: ${{ secrets.FORGEJO_TOKEN }}

      - name: Configure git
        run: |
          git config user.name "Forgejo CI"
          git config user.email "ci@forge.blackleafdigital.com"

      - name: Merge dev into main
        run: |
          git checkout main
          # Use -X theirs to prefer dev changes on conflicts
          git merge origin/dev --no-ff -X theirs -m "Merge dev into main for release ${{ github.ref_name }}"
          git push origin main

  # ===========================================
  # Publish single crate (specific crate tag only)
  # ===========================================
  publish-crate:
    needs: detect
    if: needs.detect.outputs.crate_name != ''
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ inputs.sha || github.ref }}
      - uses: https://forge.blackleafdigital.com/BlackLeafDigital/actions/setup-rust@main
      - name: Install deps
        run: sudo apt-get update && sudo apt-get install -y libseccomp-dev protobuf-compiler
      - name: Publish
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
        run: cargo publish -p ${{ needs.detect.outputs.crate_name }} --allow-dirty

  # ===========================================
  # Publish all crates (general release, after merge)
  # ===========================================
  publish-all-crates:
    needs: [detect, upload-binaries, merge-to-main]
    if: needs.detect.outputs.is_general == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ inputs.sha || github.ref }}
          fetch-depth: 0
      - uses: https://forge.blackleafdigital.com/BlackLeafDigital/actions/setup-rust@main
      - name: Install deps
        run: sudo apt-get update && sudo apt-get install -y libseccomp-dev protobuf-compiler
      - name: Publish crates that need updating
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
        run: |
          INPUT_VERSION="${{ needs.detect.outputs.version }}"

          version_gt() {
            test "$(printf '%s\n' "$1" "$2" | sort -V | head -n1)" != "$1"
          }

          get_latest_tag_version() {
            local prefix="$1"
            git tag -l "${prefix}-v*" | grep -oP '\d+\.\d+\.\d+' | sort -V | tail -n1 || echo "0.0.0"
          }

          declare -A CRATE_TAGS=(
            ["zlayer-spec"]="spec"
            ["zlayer-observability"]="obs"
            ["zlayer-overlay"]="overlay"
            ["zlayer-storage"]="storage"
            ["zlayer-core"]="core"
            ["zlayer-builder"]="builder"
            ["zlayer-init-actions"]="init"
            ["zlayer-registry"]="registry"
            ["zlayer-scheduler"]="scheduler"
            ["zlayer-tunnel"]="tunnel"
          )

          CRATES="zlayer-spec zlayer-observability zlayer-overlay zlayer-storage zlayer-core zlayer-builder zlayer-init-actions zlayer-registry zlayer-scheduler zlayer-tunnel"

          for crate in $CRATES; do
            prefix="${CRATE_TAGS[$crate]}"
            latest_tag=$(get_latest_tag_version "$prefix")

            echo "Checking $crate: latest tag=$latest_tag, input=$INPUT_VERSION"

            if [[ "$latest_tag" == "0.0.0" ]] || version_gt "$INPUT_VERSION" "$latest_tag"; then
              echo "Publishing $crate..."
              if cargo publish -p "$crate" --allow-dirty; then
                echo "Successfully published $crate"
                git tag "${prefix}-v${INPUT_VERSION}"
                git push origin "${prefix}-v${INPUT_VERSION}" || true
              else
                echo "Failed to publish $crate (may already exist)"
              fi
              sleep 30
            else
              echo "Skipping $crate (already at or above $INPUT_VERSION)"
            fi
          done

  # ===========================================
  # SDK Publishing
  # ===========================================
  publish-rust-sdk:
    needs: [detect, upload-binaries, merge-to-main]
    if: |
      needs.detect.outputs.sdk_name == 'rust' ||
      (needs.detect.outputs.is_general == 'true' && needs.merge-to-main.result == 'success')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ inputs.sha || github.ref }}
          fetch-depth: 0
      - uses: https://forge.blackleafdigital.com/BlackLeafDigital/actions/setup-rust@main
      - name: Check and publish
        working-directory: clients/zlayer-sdk/rust
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
        run: |
          INPUT_VERSION="${{ needs.detect.outputs.version }}"
          LATEST_TAG=$(git tag -l "rust-sdk-v*" | grep -oP '\d+\.\d+\.\d+' | sort -V | tail -n1 || echo "0.0.0")
          if [[ "$LATEST_TAG" == "" ]] || [[ "$(printf '%s\n' "$INPUT_VERSION" "$LATEST_TAG" | sort -V | head -n1)" != "$INPUT_VERSION" ]]; then
            echo "Publishing rust-sdk..."
            cargo publish --allow-dirty || echo "May already exist"
          else
            echo "Skipping rust-sdk (already at or above $INPUT_VERSION)"
          fi

  publish-python-sdk:
    needs: [detect, upload-binaries, merge-to-main]
    if: |
      needs.detect.outputs.sdk_name == 'python' ||
      (needs.detect.outputs.is_general == 'true' && needs.merge-to-main.result == 'success')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ inputs.sha || github.ref }}
          fetch-depth: 0
      - uses: actions/setup-python@v5
        with:
          python-version: '3.12'
      - name: Check and publish
        working-directory: clients/zlayer-sdk/python
        env:
          TWINE_USERNAME: __token__
          TWINE_PASSWORD: ${{ secrets.PYPI_TOKEN }}
        run: |
          INPUT_VERSION="${{ needs.detect.outputs.version }}"
          LATEST_TAG=$(git tag -l "py-sdk-v*" | grep -oP '\d+\.\d+\.\d+' | sort -V | tail -n1 || echo "0.0.0")
          if [[ "$LATEST_TAG" == "" ]] || [[ "$(printf '%s\n' "$INPUT_VERSION" "$LATEST_TAG" | sort -V | head -n1)" != "$INPUT_VERSION" ]]; then
            echo "Publishing python-sdk..."
            # Update version in pyproject.toml and __init__.py
            sed -i "s/^version = .*/version = \"$INPUT_VERSION\"/" pyproject.toml
            sed -i "s/__version__ = .*/__version__ = \"$INPUT_VERSION\"/" zlayer/__init__.py
            pip install build twine
            python -m build
            twine upload dist/* || echo "May already exist"
          else
            echo "Skipping python-sdk (already at or above $INPUT_VERSION)"
          fi

  publish-typescript-sdk:
    needs: [detect, upload-binaries, merge-to-main]
    if: |
      needs.detect.outputs.sdk_name == 'typescript' ||
      (needs.detect.outputs.is_general == 'true' && needs.merge-to-main.result == 'success')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ inputs.sha || github.ref }}
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: '22'
          registry-url: 'https://registry.npmjs.org'
      - name: Check and publish
        working-directory: clients/zlayer-sdk/typescript
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: |
          INPUT_VERSION="${{ needs.detect.outputs.version }}"
          LATEST_TAG=$(git tag -l "ts-sdk-v*" | grep -oP '\d+\.\d+\.\d+' | sort -V | tail -n1 || echo "0.0.0")
          if [[ "$LATEST_TAG" == "" ]] || [[ "$(printf '%s\n' "$INPUT_VERSION" "$LATEST_TAG" | sort -V | head -n1)" != "$INPUT_VERSION" ]]; then
            echo "Publishing typescript-sdk..."
            # Update version in package.json
            npm version "$INPUT_VERSION" --no-git-tag-version
            npm ci
            npm run build
            npm publish --access public || echo "May already exist"
          else
            echo "Skipping typescript-sdk (already at or above $INPUT_VERSION)"
          fi

  publish-go-sdk:
    needs: [detect, upload-binaries, merge-to-main]
    if: |
      needs.detect.outputs.sdk_name == 'go' ||
      (needs.detect.outputs.is_general == 'true' && needs.merge-to-main.result == 'success')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ inputs.sha || github.ref }}
      - uses: actions/setup-go@v5
        with:
          go-version: '1.24'
      - name: Verify Go module
        working-directory: clients/zlayer-sdk/go
        run: go mod verify

  publish-c-sdk:
    needs: [detect, upload-binaries, merge-to-main]
    if: |
      needs.detect.outputs.sdk_name == 'c' ||
      (needs.detect.outputs.is_general == 'true' && needs.merge-to-main.result == 'success')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ inputs.sha || github.ref }}
      - name: Install build dependencies
        run: sudo apt-get update && sudo apt-get install -y cmake build-essential
      - name: Verify C SDK builds
        working-directory: clients/zlayer-sdk/c
        run: |
          cmake -B build
          cmake --build build

  # ===========================================
  # Docker Push (uses pre-built images from build workflow)
  # ===========================================
  docker-push:
    needs: [detect, merge-to-main]
    if: needs.detect.outputs.docker == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Install buildah
        run: sudo apt-get update && sudo apt-get install -y buildah

      - name: Download pre-built image archives
        run: |
          for img in zlayer-node zlayer-web zlayer-manager; do
            echo "Downloading ${img}-oci.tar..."
            curl -fsSL "${{ inputs.artifact_base_url }}/${img}-oci.tar" \
              --user "zachhandley:${{ secrets.FORGEJO_ACTIONS_TOKEN }}" \
              -o ${img}-oci.tar
          done

      - name: Login to Docker Hub
        run: echo "${{ secrets.DOCKERHUB_TOKEN }}" | sudo buildah login -u zachhandley --password-stdin docker.io

      - name: Login to GHCR
        run: echo "${{ secrets.GH_ACCESS_TOKEN }}" | sudo buildah login -u "${{ github.actor }}" --password-stdin ghcr.io

      - name: Load, tag, and push images
        run: |
          set +o pipefail  # Disable pipefail to avoid SIGPIPE issues
          VERSION="${{ needs.detect.outputs.version }}"
          for img in zlayer-node zlayer-web zlayer-manager; do
            echo "Processing ${img}..."

            # Load from OCI archive - capture image ID from output
            IMAGE_ID=$(sudo buildah pull oci-archive:${img}-oci.tar | tail -1)
            echo "Loaded image ID: ${IMAGE_ID}"

            # zlayer-web only goes to Forgejo, others go to Docker Hub + GHCR
            if [ "$img" != "zlayer-web" ]; then
              # Tag for Docker Hub and GHCR
              sudo buildah tag ${IMAGE_ID} zachhandley/${img}:${VERSION}
              sudo buildah tag ${IMAGE_ID} zachhandley/${img}:latest
              sudo buildah tag ${IMAGE_ID} ghcr.io/blackleafdigital/${img}:${VERSION}
              sudo buildah tag ${IMAGE_ID} ghcr.io/blackleafdigital/${img}:latest

              # Push to Docker Hub (zachhandley namespace)
              sudo buildah push zachhandley/${img}:${VERSION}
              sudo buildah push zachhandley/${img}:latest

              # Push to GHCR (BlackLeafDigital namespace)
              sudo buildah push ghcr.io/blackleafdigital/${img}:${VERSION}
              sudo buildah push ghcr.io/blackleafdigital/${img}:latest
            fi

            # Export versioned archives for Forgejo Packages (all images)
            sudo buildah tag ${IMAGE_ID} ${img}:${VERSION}
            sudo buildah push ${img}:${VERSION} oci-archive:${img}-${VERSION}-oci.tar
          done

      - name: Upload image archives to Forgejo Packages
        run: |
          VERSION="${{ needs.detect.outputs.version }}"
          for img in zlayer-node zlayer-web zlayer-manager; do
            echo "Uploading ${img}-${VERSION}-oci.tar..."
            curl --fail --user "zachhandley:${{ secrets.FORGEJO_ACTIONS_TOKEN }}" \
              --upload-file "${img}-${VERSION}-oci.tar" \
              "https://forge.blackleafdigital.com/api/packages/BlackLeafDigital/generic/zlayer/${VERSION}/${img}-${VERSION}-oci.tar"
          done

  # ===========================================
  # Create Forgejo Release
  # ===========================================
  create-forgejo-release:
    needs: [detect, upload-binaries, docker-push]
    if: needs.detect.outputs.is_general == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: main

      - name: Create Forgejo Release
        run: |
          VERSION="${{ needs.detect.outputs.version }}"
          TAG="v${VERSION}"
          PACKAGES_URL="https://forge.blackleafdigital.com/api/packages/BlackLeafDigital/generic/zlayer/${VERSION}"

          # Create release body
          cat > release_body.md << 'RELEASE_EOF'
          ## ZLayer ${VERSION}

          ### Install

          ```bash
          # Install CLI (interactive TUI)
          curl -sSL https://raw.githubusercontent.com/BlackLeafDigital/ZLayer/main/install.sh | sh

          # Install runtime (for running containers)
          curl -sSL https://raw.githubusercontent.com/BlackLeafDigital/ZLayer/main/install.sh | ZLAYER_COMPONENT=runtime sh
          ```

          ### Binaries

          | Binary | Linux | macOS |
          |--------|-------|-------|
          | `zlayer-cli` | [amd64](${PACKAGES_URL}/zlayer-cli-linux-amd64.tar.gz) / [arm64](${PACKAGES_URL}/zlayer-cli-linux-arm64.tar.gz) | [amd64](${PACKAGES_URL}/zlayer-cli-darwin-amd64.tar.gz) / [arm64](${PACKAGES_URL}/zlayer-cli-darwin-arm64.tar.gz) |
          | `zlayer-build` | [amd64](${PACKAGES_URL}/zlayer-build-linux-amd64.tar.gz) / [arm64](${PACKAGES_URL}/zlayer-build-linux-arm64.tar.gz) | [amd64](${PACKAGES_URL}/zlayer-build-darwin-amd64.tar.gz) / [arm64](${PACKAGES_URL}/zlayer-build-darwin-arm64.tar.gz) |
          | `zlayer` | [amd64](${PACKAGES_URL}/zlayer-linux-amd64.tar.gz) / [arm64](${PACKAGES_URL}/zlayer-linux-arm64.tar.gz) | [amd64](${PACKAGES_URL}/zlayer-darwin-amd64.tar.gz) / [arm64](${PACKAGES_URL}/zlayer-darwin-arm64.tar.gz) |

          ### Container Images

          **Docker Hub** (`zachhandley/`):
          ```bash
          docker pull zachhandley/zlayer-node:${VERSION}
          docker pull zachhandley/zlayer-manager:${VERSION}
          ```

          **GHCR** (`ghcr.io/blackleafdigital/`):
          ```bash
          docker pull ghcr.io/blackleafdigital/zlayer-node:${VERSION}
          docker pull ghcr.io/blackleafdigital/zlayer-manager:${VERSION}
          ```

          **Forgejo Packages** (includes `zlayer-web`):
          - [zlayer-node](${PACKAGES_URL}/zlayer-node-${VERSION}-oci.tar)
          - [zlayer-manager](${PACKAGES_URL}/zlayer-manager-${VERSION}-oci.tar)
          - [zlayer-web](${PACKAGES_URL}/zlayer-web-${VERSION}-oci.tar) *(Forgejo only)*

          ### Using with ZLayer

          Pull and run images directly with ZLayer:
          ```bash
          # Pull images
          zlayer pull zachhandley/zlayer-node:${VERSION}
          zlayer pull zachhandley/zlayer-manager:${VERSION}

          # Or deploy from a spec file
          zlayer deploy my-deployment.yaml
          ```

          ### What's Changed

          See the [CHANGELOG](https://forge.blackleafdigital.com/BlackLeafDigital/ZLayer/src/branch/main/CHANGELOG.md) for details.
          RELEASE_EOF

          # Substitute VERSION in the body
          sed -i "s/\${VERSION}/${VERSION}/g" release_body.md
          sed -i "s|\${PACKAGES_URL}|${PACKAGES_URL}|g" release_body.md

          # Create release via Forgejo API
          curl -X POST \
            -H "Authorization: token ${{ secrets.FORGEJO_TOKEN }}" \
            -H "Content-Type: application/json" \
            "${{ github.server_url }}/api/v1/repos/${{ github.repository }}/releases" \
            -d "$(jq -n \
              --arg tag "$TAG" \
              --arg name "ZLayer $VERSION" \
              --arg body "$(cat release_body.md)" \
              '{tag_name: $tag, name: $name, body: $body, draft: false, prerelease: false}'
            )"

  # ===========================================
  # Trigger GitHub release
  # ===========================================
  trigger-github:
    needs: [detect, upload-binaries, merge-to-main, docker-push, publish-all-crates]
    if: always() && needs.detect.outputs.is_general == 'true' && needs.upload-binaries.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Trigger GitHub E2E + Release
        run: |
          curl -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${{ secrets.GH_ACCESS_TOKEN }}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            https://api.github.com/repos/BlackLeafDigital/ZLayer/actions/workflows/e2e.yml/dispatches \
            -d '{"ref":"main","inputs":{"version":"${{ needs.detect.outputs.version }}","sha":"${{ github.sha }}"}}'

  # ===========================================
  # Cleanup temp packages (runs after all jobs)
  # ===========================================
  cleanup:
    needs: [detect, upload-binaries, merge-to-main, docker-push, publish-all-crates, publish-rust-sdk, publish-python-sdk, publish-typescript-sdk, publish-go-sdk, publish-c-sdk, create-forgejo-release, trigger-github]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Cleanup temp packages
        run: |
          RUN_ID=$(echo "${{ inputs.artifact_base_url }}" | grep -oP 'zlayer-temp/\K[^/]+')
          echo "Cleaning up temp packages for run_id: ${RUN_ID}"
          curl -X DELETE \
            --user "zachhandley:${{ secrets.FORGEJO_ACTIONS_TOKEN }}" \
            "https://forge.blackleafdigital.com/api/packages/BlackLeafDigital/generic/zlayer-temp/${RUN_ID}" || true
