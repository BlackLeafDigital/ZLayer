"""
ZLayer WASM HTTP Handler Example - Python

This example demonstrates implementing the wasi:http/incoming-handler interface
using Python and componentize-py to create a serverless HTTP handler that runs
in ZLayer's WASM runtime.

Building:
    # Install componentize-py
    pip install componentize-py

    # Build the WASM component
    componentize-py -d ../../../../wit -w wasi:http/proxy@0.2.0 componentize app -o hello-handler.wasm

    # Or with a specific Python version
    componentize-py -d ../../../../wit -w wasi:http/proxy@0.2.0 componentize app -o hello-handler.wasm

Endpoints:
    - GET /         - Returns a welcome message with request info
    - GET /health   - Health check endpoint
    - POST /echo    - Echoes back the request body as JSON
    - Any other     - Returns 404 Not Found

Note: componentize-py is actively developed. Check for the latest version
and API compatibility at: https://github.com/bytecodealliance/componentize-py
"""

import json
from typing import Optional

# These imports are generated by componentize-py from the WIT definitions
from proxy import exports
from proxy.types import Ok
from proxy.imports.types import (
    IncomingRequest,
    ResponseOutparam,
    OutgoingResponse,
    Fields,
    OutgoingBody,
    Method,
)


class IncomingHandler(exports.IncomingHandler):
    """
    HTTP handler implementation for ZLayer.

    This class implements the wasi:http/incoming-handler interface,
    which is called by the ZLayer runtime for each incoming HTTP request.
    """

    def handle(self, request: IncomingRequest, response_out: ResponseOutparam) -> None:
        """
        Handle an incoming HTTP request.

        Args:
            request: The incoming HTTP request
            response_out: The response output parameter to write the response to
        """
        # Extract request information
        method = request.method()
        path = request.path_with_query() or "/"

        # Convert method to string
        method_str = self._method_to_string(method)

        # Route the request
        status_code, content_type, body = self._route_request(method_str, path, request)

        # Build response headers
        headers = Fields.from_list([
            ("content-type", content_type.encode()),
            ("x-zlayer-plugin", b"hello-handler-python"),
        ])

        # Create the response
        response = OutgoingResponse(headers)
        response.set_status_code(status_code)

        # Write the response body
        outgoing_body = response.body()
        stream = outgoing_body.write()
        stream.blocking_write_and_flush(body.encode())
        # Stream is automatically dropped when it goes out of scope
        OutgoingBody.finish(outgoing_body, None)

        # Send the response
        ResponseOutparam.set(response_out, Ok(response))

    def _route_request(
        self, method: str, path: str, request: IncomingRequest
    ) -> tuple[int, str, str]:
        """
        Route the request to the appropriate handler.

        Args:
            method: The HTTP method as a string
            path: The request path
            request: The full incoming request

        Returns:
            Tuple of (status_code, content_type, body)
        """
        if method == "GET" and path in ("/", ""):
            response_data = {
                "message": "Hello from Python WASM!",
                "method": method,
                "path": path,
                "runtime": "wasi-preview2",
                "lang": "python",
            }
            return 200, "application/json", json.dumps(response_data)

        elif method == "GET" and path == "/health":
            response_data = {
                "status": "healthy",
                "plugin": "hello-handler-python",
            }
            return 200, "application/json", json.dumps(response_data)

        elif method == "POST" and path == "/echo":
            # Read the request body
            body_content = self._read_request_body(request)
            response_data = {
                "echoed": True,
                "length": len(body_content),
                "content": body_content,
            }
            return 200, "application/json", json.dumps(response_data)

        else:
            response_data = {
                "error": "Not Found",
                "method": method,
                "path": path,
            }
            return 404, "application/json", json.dumps(response_data)

    def _method_to_string(self, method: Method) -> str:
        """
        Convert a WASI HTTP Method to a string.

        Args:
            method: The WASI HTTP method variant

        Returns:
            The method as an uppercase string
        """
        # Method is a variant type, check each variant
        if hasattr(method, "get") and method.get is not None:
            return "GET"
        elif hasattr(method, "post") and method.post is not None:
            return "POST"
        elif hasattr(method, "put") and method.put is not None:
            return "PUT"
        elif hasattr(method, "delete") and method.delete is not None:
            return "DELETE"
        elif hasattr(method, "patch") and method.patch is not None:
            return "PATCH"
        elif hasattr(method, "head") and method.head is not None:
            return "HEAD"
        elif hasattr(method, "options") and method.options is not None:
            return "OPTIONS"
        elif hasattr(method, "connect") and method.connect is not None:
            return "CONNECT"
        elif hasattr(method, "trace") and method.trace is not None:
            return "TRACE"
        elif hasattr(method, "other"):
            return method.other or "UNKNOWN"
        else:
            # Try string representation as fallback
            return str(method).upper()

    def _read_request_body(self, request: IncomingRequest) -> str:
        """
        Read the full request body as a UTF-8 string.

        Args:
            request: The incoming HTTP request

        Returns:
            The request body as a string, or empty string on error
        """
        try:
            body = request.consume()
            stream = body.stream()

            data = bytearray()
            while True:
                try:
                    chunk = stream.blocking_read(4096)
                    if not chunk:
                        break
                    data.extend(chunk)
                except Exception:
                    break

            return data.decode("utf-8", errors="replace")
        except Exception:
            return ""
